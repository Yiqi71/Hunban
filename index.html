<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>é­‚è›‹å°åŸ</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'AlibabaSans';
            src: url('assets/fonts/AlibabaSans-Regular.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }

        html,
        body {
            touch-action: none;
            /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤æ‰‹åŠ¿ï¼ˆæ»‘åŠ¨/ç¼©æ”¾/åŒæŒ‡æ“ä½œï¼‰ */
            -webkit-user-select: none;
            /* iOS Safari ç¦æ­¢é€‰ä¸­ */
            -ms-user-select: none;
            /* IEç¦ç”¨é€‰ä¸­ */
            user-select: none;
            /* æ ‡å‡†ç¦ç”¨é€‰ä¸­ */
            -webkit-touch-callout: none;
            /* iOS Safari ç¦æ­¢é•¿æŒ‰å¼¹å‡ºèœå• */
        }

        body {
            user-select: none;
            font-family: 'AlibabaSans', sans-serif;
            font-weight: 400;
            margin: 0;
            overflow: hidden;
            position: relative;
            background-color: black;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            align-items: center;
        }

        menu {
            z-index: 10;
            position: relative;
            /* display: flex;
            align-items: center;
            justify-content: center; */
            /* border: solid 1px white; */
            width: 90vw;
        }

        #logo {
            width: 100px;
            position: absolute;
            left: 0;
        }

        canvas {
            display: block;
            position: absolute;
            z-index: 1;
        }

        .buttons {
            position: absolute;
            /* top: 20px;
            left: 20px; */
            bottom: 5em;
            z-index: 10;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
        }

        .button {
            width: 120px;
            height: 60px;
            padding: 10px;
            /* border: solid 1px white; */
        }

        .buttons .button img {
            width: 120px;
            height: auto;
            z-index: 1;
            position: absolute;
        }

        /* å…¬å…±éƒ¨åˆ†ï¼Œæ‰€æœ‰å±å¹•éƒ½ç”¨ */
        .buttons .button button {
            font-family: 'AlibabaSans', sans-serif;
            font-weight: 500;
            z-index: 10;
            position: absolute;
            width: 120px;
            height: 60px;
            background: none;
            border: none;
            cursor: pointer;
            color: black;
        }

        /* å°å±ï¼ˆ<= 430pxï¼‰è°ƒæ•´å­—ä½“å¤§å° */
        @media (max-width: 580px) {
            #logo {
                width: 100px;
                position: absolute;
                left: 20px;
            }

            .button {
                width: 100px;
                height: 50px;
            }

            .buttons .button img {
                width: 100px;
                height: auto;
            }

            .buttons .button button {
                font-size: 16px !important;
                width: 100px;
                height: 50px;
            }
        }

        /* ä¸­å±ä»¥ä¸Š (> 430px) è°ƒæ•´å­—ä½“å¤§å° */
        @media (min-width: 581px) {
            .buttons .button button {
                font-size: 18px;
            }
        }
    </style>
</head>

<body>
    <menu>
        <img id="logo" alt="logo" src="assets/logo-yellow.png" width=50>
    </menu>
    <canvas id="xiaoyuan"></canvas>
    <div class="buttons">
        <div class="button">
            <button onclick="triggerAction('greet')">
                æ‰“æ‹›å‘¼
            </button>
            <img src="assets/Asset 3.png" alt="button" width="120">
        </div>

        <div class="button">
            <img src="assets/Asset 3.png" alt="button" width="120">
            <button onclick="triggerAction('happy')">
                å¼€å¿ƒ
            </button>
        </div>

        <div class="button">
            <img src="assets/Asset 3.png" alt="button" width="120">
            <button onclick="triggerAction('sad')">
                ä¼¤å¿ƒ
            </button>
        </div>

        <div class="button">
            <img src="assets/Asset 3.png" alt="button" width="120">
            <button onclick="triggerAction('think')">
                æ€è€ƒ
            </button>
        </div>

        <div class="button">
            <img src="assets/Asset 3.png" alt="button" width="120">
            <button onclick="triggerAction('jump')">
                æ¬¢å‘¼
            </button>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        const canvas = document.getElementById("xiaoyuan");

        let scene, camera, renderer;
        let body, headGroup, head;
        let targetRotation = {
            groupX: 0,
            groupY: 0,
            groupZ: 0,
            headX: 0,
            headY: 0,
            headZ: 0
        };
        let isActionPlaying = false; // æ§åˆ¶æ˜¯å¦å¯ä»¥pressæœå‘
        let isPressing = false; // æ˜¯å¦æŒ‰ç€
        let isReturning = false; // æ˜¯å¦æ­£åœ¨å½’ä½ä¸­

        let returnStartTime = 0;
        let returnDuration = 500; // å½’é›¶æ—¶é—´ 500ms

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isTickling = false;
        let tickleStartTime = 0;
        let laughSound;

        let pressTimer = null;

        let jumpOffset = 0; // æ§åˆ¶è·³è·ƒçš„é¢å¤–åç§»é‡

        let facePlane;
        const textureLoader = new THREE.TextureLoader();

        // åˆ›å»ºPlane
        function createFacePlane() {
            const faceTexture = textureLoader.load('assets/default.png');
            const faceMaterial = new THREE.MeshBasicMaterial({
                map: faceTexture,
                transparent: true,
                side: THREE.DoubleSide // åŒé¢å¯è§ï¼Œé˜²æ­¢æ—‹è½¬åæ¶ˆå¤±
            });

            const faceGeometry = new THREE.PlaneGeometry(0.18, 0.1); // å®½é«˜å¯ä»¥è°ƒæ•´
            facePlane = new THREE.Mesh(faceGeometry, faceMaterial);

            facePlane.position.set(0, 0.15, 0.5); // æŒ‰å¤´çš„ä½ç½®å¾®è°ƒ
            head.add(facePlane); // ç›´æ¥åŠ åœ¨headä¸Šï¼
        }

        // çœ¨çœ¼
        let nextBlinkTime = (Date.now() + getRandomBlinkInterval()) / 1000;
        let blinking = false;
        let blinkStartTime = 0;

        function getRandomBlinkInterval() {
            return 5000 + Math.random() * 3000; // æ¯5~8ç§’çœ¨ä¸€æ¬¡
        }


        init();
        animate();

        // é¢„åŠ è½½è¡¨æƒ…å›¾ç‰‡
        const faceTextures = {
            default: textureLoader.load('assets/default.png'),
            greet: textureLoader.load('assets/wink.png'),
            laugh: textureLoader.load('assets/laugh.png'),
            smile: textureLoader.load('assets/smile.png')
        };


        // åˆå§‹åŒ–xiaoyuan
        function init() {
            laughSound = new Audio('assets/giggling-6799.mp3');
            scene = new THREE.Scene();
            scene.background = new THREE.Color("black");

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1, 3);

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 2, 3);
            scene.add(light);

            // fac959
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            // const yellow = new THREE.AmbientLight(0xfac959, 0.1);
            // scene.add(yellow);

            const loader = new THREE.GLTFLoader();

            loader.load('assets/hunban-body.glb', function (gltf) {
                body = gltf.scene;
                body.position.set(0, 0.5, 0);
                scene.add(body);
            });

            const headOffset = new THREE.Group();
            loader.load('assets/hunban-head.glb', function (gltf) {
                headGroup = new THREE.Group();
                head = gltf.scene;
                head.position.set(0, 0, 0);
                headGroup.position.set(0, 0.5, 0);
                headOffset.position.set(0, 0.6, 0);
                headGroup.add(headOffset);
                headOffset.add(head);
                scene.add(headGroup);

                console.log("head position in group:", head.position);
                createFacePlane();
            });


            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onPressStart);
            window.addEventListener('mouseup', onPressEnd);

            window.addEventListener('touchstart', onPressStart);
            window.addEventListener('touchend', onPressEnd);
        }

        // é€‚åº”çª—å£å¤§å°å˜åŒ–
        function adjustCameraPosition() {
            const baseWidth = 1440; // ä½ è®¾è®¡æ—¶çš„å‚è€ƒå®½åº¦ï¼Œæ¯”å¦‚1440px
            const scaleFactor = window.innerWidth / baseWidth;

            if (camera) {
                camera.position.z = 3 / scaleFactor; // åŸæ¥æ˜¯3ï¼Œç°åœ¨æ ¹æ®æ¯”ä¾‹ç¼©æ”¾
            }
        }


        function onWindowResize() {
            // camera.aspect = window.innerWidth / window.innerHeight;
            // camera.updateProjectionMatrix();
            // renderer.setSize(window.innerWidth, window.innerHeight);

            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);

            // æ ¹æ®çª—å£æ¯”ä¾‹ï¼Œè°ƒæ•´cameraè§†è§’å¤§å°
            if (camera) {
                if (width < 600) {
                    camera.fov = 60; // å°å±å¹•ï¼Œæ¯”å¦‚æ‰‹æœºï¼Œè§†è§’å¼€å¤§ä¸€ç‚¹
                } else {
                    camera.fov = 45; // å¤§å±å¹•ï¼Œæ­£å¸¸
                }
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }

        }

        function smoothStep(progress) {
            return progress * progress * (3 - 2 * progress);
        }


        // xiaoyuançš„åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001; // å½“å‰æ—¶é—´ï¼Œç§’


            // çœ¨çœ¼
            if (!isActionPlaying && !blinking && time > nextBlinkTime) {
                // console.log("canBlink")
                // å¼€å§‹çœ¨çœ¼
                blinking = true;
                blinkStartTime = time;
            }

            if (blinking) {
                const blinkElapsed = time - blinkStartTime;

                if (blinkElapsed < 0.5) {
                    // æ­£åœ¨çœ¨çœ¼
                    const blinkProgress = blinkElapsed / 0.5; // 0 ~ 1ä¹‹é—´
                    const scaleY = 1 - 0.6 * Math.sin(blinkProgress * Math.PI);
                    facePlane.scale.set(1, scaleY, 1);
                } else {
                    // çœ¨çœ¼ç»“æŸ
                    facePlane.scale.set(1, 1, 1);
                    blinking = false;
                    nextBlinkTime = (Date.now() + getRandomBlinkInterval()) / 1000; // å®‰æ’ä¸‹ä¸€æ¬¡çœ¨çœ¼
                    // console.log("blink");
                }
            }


            if (body) {
                // âœ¨ å‘¼å¸ä¸Šä¸‹æµ®åŠ¨
                const baseY = 0.5; // èº«ä½“é»˜è®¤yä½ç½®ï¼ˆä½ åŸæ¥è®¾ç½®çš„æ˜¯0.5ï¼‰
                const breathingHeight = 0.02; // æµ®åŠ¨å¹…åº¦ï¼ˆä¸Šä¸‹2cmï¼‰
                const breathingSpeed = 2; // å‘¼å¸é€Ÿåº¦ï¼ˆè¶Šå°è¶Šæ…¢ï¼Œä¸€æ¬¡å‘¼å¸å¤§æ¦‚3ç§’ï¼‰

                const breathing = Math.sin(time * breathingSpeed) * breathingHeight;
                body.position.y = baseY + breathing + jumpOffset; // âœ¨ å¤´è·Ÿéšèº«ä½“å‘¼å¸ï¼Œæœ‰å¼¹æ€§

                if (headGroup) {
                    const targetHeadY = body.position.y // å¤´ç›¸å¯¹äºèº«ä½“çš„æ ‡å‡†é«˜åº¦
                    headGroup.position.y += (targetHeadY - headGroup.position.y) * 0.05;
                    // 0.05æ˜¯å¼¹æ€§è·Ÿéšé€Ÿåº¦ï¼Œè¶Šå°è¶Šè½¯
                }
            }

            if (isReturning) {
                const returnSpeed = 0.04; // æ§åˆ¶å½’é›¶çš„å¿«æ…¢ï¼Œè¶Šå°è¶Šæ…¢
                const timeElapsed = (Date.now() - returnStartTime) / returnDuration; // å½’é›¶è¿›è¡Œåˆ°å¤šå°‘äº†
                const progress = Math.min(timeElapsed, 1);
                const eased = smoothStep(progress);

                targetRotation.groupX *= (1 - eased);
                targetRotation.groupY *= (1 - eased);
                targetRotation.groupZ *= (1 - eased);
                targetRotation.headX *= (1 - eased);
                targetRotation.headY *= (1 - eased);
                targetRotation.headZ *= (1 - eased);

                if (progress >= 1) {
                    isReturning = false; // å½’é›¶å®Œæˆ
                }
            }

            if (isTickling) {
                const now = Date.now();
                const elapsed = (now - tickleStartTime) / 1000; // ç§’æ•°
                const tickleDuration = 1.0; // æŒ ç—’æ€»æ—¶é•¿ï¼ˆç§’ï¼‰

                let intensity = 1.0;
                facePlane.material.map = faceTextures.laugh;
                facePlane.scale.set(1.5, 1, 1);
                if (elapsed > tickleDuration) {
                    // æ¸å˜æ”¶å°¾ï¼Œè¶…è¿‡tickleDurationåå¼€å§‹å‡å°‘
                    const fadeElapsed = elapsed - tickleDuration;
                    const fadeDuration = 1.0; // æ”¶å°¾æ¸å˜æ—¶é—´ï¼ˆç§’ï¼‰
                    intensity = Math.max(0, 1 - fadeElapsed / fadeDuration); // ä»1é€æ¸å‡åˆ°0
                    if (intensity === 0) {
                        isTickling = false; // æ”¶å°¾å®Œæˆï¼Œåœæ­¢tickle
                        laughSound.pause();

                        targetRotation = {
                            groupX: 0,
                            groupY: 0,
                            groupZ: 0,
                            headX: 0,
                            headY: 0,
                            headZ: 0
                        };
                        // body.position.set(0, 0.5, 0);
                        const targetVec = new THREE.Vector3(0, 0.5, 0);
                        body.position.lerp(targetVec, 0.1); // æ¯å¸§é è¿‘ç›®æ ‡
                    }
                }

                if (elapsed > 1.65) {
                    facePlane.material.map = faceTextures.default;
                    facePlane.scale.set(1, 1, 1);
                }

                // æ•´ä½“Groupå°å¹…åº¦å¿«é€Ÿå·¦å³æ‘‡æ‘†
                headGroup.rotation.z = Math.sin((now - tickleStartTime) * 0.05 * (0.4 * intensity + 0.6)) * 0.07 *
                    intensity;
                headGroup.rotation.x = Math.sin((now - tickleStartTime) * 0.03 * (0.4 * intensity + 0.6)) * 0.08 *
                    intensity;

                // å¤´éƒ¨å åŠ æ›´ç»†å¾®çš„é¢¤åŠ¨
                head.rotation.z = Math.sin((now - tickleStartTime) * 0.08 * (0.4 * intensity + 0.6)) * 0.05 * intensity;
                head.rotation.x = Math.sin((now - tickleStartTime) * 0.06 * (0.4 * intensity + 0.6)) * 0.03 * intensity;

                // èº«ä½“è½»å¾®æ™ƒåŠ¨
                body.position.z = Math.sin((now - tickleStartTime) * 0.08 * (0.4 * intensity + 0.6)) * 0.05 * intensity;
                body.position.x = Math.sin((now - tickleStartTime) * 0.06 * (0.4 * intensity + 0.6)) * 0.04 * intensity;
            }


            if (headGroup) {
                // headGroupå›´ç»•bodyçš„ä¸­å¿ƒè½¬åŠ¨ï¼ˆx/y/zï¼‰
                headGroup.rotation.x += (targetRotation.groupX - headGroup.rotation.x) * 0.1;
                headGroup.rotation.y += (targetRotation.groupY - headGroup.rotation.y) * 0.1;
                headGroup.rotation.z += (targetRotation.groupZ - headGroup.rotation.z) * 0.1;
            }

            if (head) {
                // headå±€éƒ¨åŠ¨ä½œï¼ˆä»¥headè‡ªå·±çš„åŸç‚¹è½¬åŠ¨ï¼‰
                head.rotation.x += (targetRotation.headX - head.rotation.x) * 0.1;
                head.rotation.y += (targetRotation.headY - head.rotation.y) * 0.1;
                head.rotation.z += (targetRotation.headZ - head.rotation.z) * 0.1;
            }


            renderer.render(scene, camera);
        }


        // æŒ‰é’®è§¦å‘åŠ¨ä½œ
        function triggerAction(type) {
            if (isActionPlaying) return; // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œä¸å…è®¸å†æ¬¡ç‚¹å‡»

            // å½’é›¶
            isReturning = true;
            returnStartTime = Date.now();

            setTimeout(() => {
                // âœ¨ ç­‰å½’é›¶ä¸€æ®µæ—¶é—´åå†å¼€å§‹æ–°åŠ¨ä½œ
                isReturning = false;
                startAction(type);
            }, 500); // å½’é›¶æ—¶é—´ï¼Œæ¯”å¦‚0.5ç§’
        }

        function startAction(type) {
            isActionPlaying = true;

            let startTime = Date.now();
            let actionDuration = 1200; // é»˜è®¤
            if (type === 'greet') {
                actionDuration = 1100;
            } else if (type === 'happy') {
                actionDuration = 1400;
            } else if (type === 'think') {
                actionDuration = 3000;
            } else if (type === 'sad') {
                actionDuration = 3000;
            }


            // åˆ‡æ¢è¡¨æƒ…
            if (facePlane && facePlane.material) {
                if (type === 'happy') {
                    facePlane.material.map = faceTextures.smile;
                    facePlane.scale.set(1.3, 0.6, 1);
                } else if (type === 'jump') {
                    facePlane.material.map = faceTextures.smile;
                    facePlane.scale.set(1.3, 0.6, 1);
                } else {
                    facePlane.material.map = faceTextures.default;
                    facePlane.scale.set(1, 1, 1);
                }
                facePlane.material.needsUpdate = true;
            }
            // è®¾ç½®ä¸åŒåŠ¨ä½œ
            function updateAction() {
                const elapsed = (Date.now() - startTime); // 0~1ä¹‹é—´
                const progress = elapsed / actionDuration; // 0 ~ 1ä¹‹é—´

                if (type === 'greet') {
                    if (progress < 0.35) {
                        // é˜¶æ®µ1ï¼šåæ–¹å‘è“„åŠ›ï¼ˆæ›´ä¹…æ›´å¤§ï¼‰
                        const subProgress = progress / 0.35; // 0 ~ 1
                        const eased = Math.sin((subProgress * Math.PI) / 2);
                        targetRotation.groupZ = 0.45 * eased; // ä»0åˆ°0.3å¼§åº¦ï¼ˆçº¦17åº¦ï¼‰
                        targetRotation.groupX = -0.25 * eased; // æ›´æ˜æ˜¾å¾€åä»°
                        headGroup.rotation.z = 0.45 * eased; // ä»0åˆ°0.3å¼§åº¦ï¼ˆçº¦17åº¦ï¼‰
                        headGroup.rotation.x = -0.25 * eased; // æ›´æ˜æ˜¾å¾€åä»°
                    } else if (progress < 0.5) {
                        // é˜¶æ®µ2ï¼šå¿«é€Ÿå°å¹…åº¦åˆ°å³è¾¹æœ€å¤§è§’åº¦
                        const subProgress = (progress - 0.32) / (0.5 - 0.32); // 0 ~ 1
                        const eased = Math.sin((subProgress * Math.PI) / 2);
                        headGroup.rotation.z = 0.45 - 0.65 * eased;
                        headGroup.rotation.x = -0.25 + 0.45 * eased;
                        targetRotation.groupZ = 0.45 - 0.65 * eased;
                        targetRotation.groupX = -0.25 + 0.45 * eased;
                    } else {
                        // é˜¶æ®µ3ï¼šåœåœ¨å³è¾¹ï¼Œç»´æŒå§¿åŠ¿
                        targetRotation.groupZ = -0.2;
                        targetRotation.groupX = 0.2;

                    }

                    if (progress > 0.99) {
                        targetRotation.groupZ = 0;
                        targetRotation.groupX = 0;
                        if (facePlane) {
                            facePlane.material.map = faceTextures.default;
                            facePlane.scale.set(1, 1, 1);
                            facePlane.material.needsUpdate = true;
                        }
                    } else if (progress > 0.45) {
                        // wink
                        facePlane.material.map = faceTextures.greet;
                        facePlane.scale.set(1.01, 1, 1);
                    }
                } else if (type === 'happy') {
                    targetRotation.groupZ = 0.3 * Math.sin(progress * Math.PI * 4);
                    if (progress > 0.95) {
                        if (facePlane) {
                            facePlane.material.map = textureLoader.load('assets/default.png'); // ç¬‘è„¸å›¾ç‰‡
                            facePlane.scale.set(1, 1, 1);
                            facePlane.material.needsUpdate = true;
                        }
                    }
                } else if (type === 'jump') {
                    // âœ¨ happyï¼šè·³è·ƒä¸¤æ¬¡
                    let jumpHeight = 0.7; // ä¸»è·³é«˜åº¦ï¼ˆå¯ä»¥è‡ªå·±è°ƒï¼‰
                    let smallJumpHeight = 0.4; // æ¬¡è·³é«˜åº¦

                    if (progress < 0.7) {
                        // ç¬¬ä¸€è·³ï¼ˆ0% - 50%ï¼‰
                        const subProgress = progress / 0.7; // 0~1
                        if (subProgress < 0.4) {
                            // è“„åŠ›é˜¶æ®µï¼ˆ0~0.5ï¼‰
                            const down = Math.sin(subProgress * Math.PI) * 0.1; // å‘ä¸‹å‹ç¼©ä¸€ç‚¹
                            jumpOffset = -down;
                        } else {
                            const upProgress = (subProgress - 0.4) * 2;
                            const height = jumpHeight * Math.sin(upProgress * Math.PI);
                            jumpOffset = height;
                        }
                    } else {
                        // ç¬¬äºŒè·³ï¼ˆ50% - 100%ï¼‰
                        const subProgress = (progress - 0.7) / 0.3; // 0~1
                        const height = smallJumpHeight * Math.sin(subProgress * Math.PI);
                        jumpOffset = height;
                    }


                    // âœ¨ å¤´éƒ¨æ»åè·Ÿéšï¼ˆå¸¦å¼¹æ€§ï¼‰
                    const bodyYTarget = 0.5 + jumpOffset;;
                    const headY = headGroup.position.y;
                    const diff = bodyYTarget - headY;
                    headGroup.position.y += diff * 0.15; // è¶Šå°è¶Šæ»å
                    headGroup.rotation.x = -diff * 0.05; // æ ¹æ®ä¸Šä¸‹å·®å€¼å¾®å¾®æŠ¬å¤´ä½å¤´ï¼ˆå¢å¼ºè°ƒæ€§ï¼‰

                    // âœ¨ åŠ¨ä½œå¿«ç»“æŸæ—¶ï¼ŒåŠ ä¸€ç‚¹å°å¼¹åŠ¨
                    if (progress > 0.9) {
                        const t = (progress - 0.9) / 0.1; // 0~1
                        const bounce = Math.sin(t * Math.PI * 3) * (1 - t) * 0.02; // å°å¹…åº¦å¼¹åŠ¨ï¼Œå¹…åº¦é€æ¸å‡å°
                        jumpOffset += bounce;
                    }

                    // âœ¨ æ¢å¤è¡¨æƒ…
                    if (progress > 0.95) {
                        if (facePlane) {
                            facePlane.material.map = faceTextures.default;
                            facePlane.scale.set(1, 1, 1);
                            facePlane.material.needsUpdate = true;
                        }
                    }


                } else if (type === 'sad') {
                    if (facePlane && facePlane.scale) {
                        if (progress < 0.15) {
                            // âœ¨ 0~25%ï¼šçœ¼ç›æ”¾å¤§å†å›ç¼©
                            const expand = progress < 0.075 ? (progress / 0.075) : (1 - (progress - 0.075) / 0.075);
                            const scaleFactor = 1 + expand * 0.3; // æœ€å¤šæ”¾å¤§åˆ°2.5å€
                            facePlane.scale.set(1, 1 * scaleFactor, 1);
                        } else if (progress >= 0.15 && progress < 0.3) {
                            // âœ¨ 25%~50%ï¼šåœé¡¿ï¼Œçœ¼ç›æ¢å¤æ­£å¸¸
                            facePlane.scale.set(1, 1, 1);
                            targetRotation.headX = 0;
                            targetRotation.headY = 0;
                        } else if (progress >= 0.3 && progress < 0.54) {
                            // âœ¨ 50%~90%ï¼šå¼€å§‹æ…¢æ…¢å‘å³ä¸‹æ–¹ä½å¤´
                            facePlane.scale.set(1, 1, 1);
                            const moveProgress = (progress - 0.3) / 0.24; // ä»0åˆ°1
                            targetRotation.headX = 0.2 * moveProgress;
                            targetRotation.headY = 0.12 * moveProgress;
                            targetRotation.groupX = 0.3 * moveProgress;
                            targetRotation.groupY = 0.1 * moveProgress;
                            targetRotation.groupZ = -0.1 * moveProgress;
                        } else {
                            // âœ¨ 90%~100%ï¼šçœ¨çœ¼

                            // if (progress >= 0.8) {
                            //     const blinkProgress = (progress - 0.8) / 0.1;
                            //     const scaleY = 1 - 0.6 * Math.sin(blinkProgress * Math.PI/2);
                            //     facePlane.scale.set(1, scaleY, 1);
                            // }
                            const shakeProgress = (progress - 0.54) / 0.46;
                            const shake = Math.sin(shakeProgress * Math.PI * 3) * 0.08; // æ‘†åŠ¨2æ¬¡ï¼Œå¹…åº¦Â±0.05å¼§åº¦
                            targetRotation.headY = 0.12 + shake; // åœ¨åŸæœ¬ä½å¤´å³åçš„åŸºç¡€ä¸Šå·¦å³è½»è½»æ‘†åŠ¨
                            targetRotation.headX = 0.2; // ä¿æŒä½å¤´
                            targetRotation.groupX = 0.3;
                            targetRotation.groupY = 0.1;
                            targetRotation.groupZ = -0.1;
                        }
                    }
                } else if (type === 'think') {
                    if (progress < 0.08) {
                        // çœ¨çœ¼
                        const blinkProgress = progress / 0.08;
                        const scaleY = 1 - 0.5 * Math.sin(blinkProgress * Math.PI);
                        facePlane.scale.set(1, scaleY, 1);
                    } else if (progress >= 0.08 && progress < 0.09) {
                        targetRotation.headY = 0;
                        targetRotation.headX = 0;
                    } else if (progress >= 0.09 && progress < 0.17) {
                        const blinkProgress = (progress - 0.09) / 0.08;
                        const scaleY = 1 - 0.5 * Math.sin(blinkProgress * Math.PI);
                        facePlane.scale.set(1, scaleY, 1);
                    } else if (progress >= 0.17 && progress < 0.38) {
                        targetRotation.headY = 0;
                        targetRotation.headX = 0;
                    } else {
                        // å¤´å¾®å¾®æ­ªæ–œ
                        const moveProgress = (progress - 0.38) / 0.62; // ä»0åˆ°1
                        targetRotation.headX = -0.2 * moveProgress;
                        targetRotation.headY = 0.1 * moveProgress;
                    }

                }

                if (elapsed < actionDuration) {
                    requestAnimationFrame(updateAction);
                } else {
                    // åŠ¨ä½œç»“æŸ
                    isActionPlaying = false;
                }
            }
            updateAction();
        }

        // æŒ ç—’ç—’
        function triggerTickle() {
            if (isTickling) return; // å¦‚æœæ­£åœ¨æŒ ï¼Œä¸è¦é‡å¤æŒ 

            isTickling = true;
            tickleStartTime = Date.now();

            if (laughSound) {
                console.log("soundPlayed");
                laughSound.currentTime = 2.5;
                laughSound.play();
            }

            // 0.8ç§’ååœæ­¢æŒ 
            // setTimeout(() => {
            //     isTickling = false;
            //     // å½’é›¶
            //     if (head) {
            //         head.rotation.set(0, 0, 0);
            //     }
            // }, 2000);
        }

        // ç›®å…‰è·Ÿéš
        function onPressStart(event) {
            // æ–°åŠ ï¼šå¦‚æœç‚¹å‡»çš„æ˜¯buttonå…ƒç´ ï¼Œå°±ä¸å¤„ç†
            if (event.target.tagName === 'BUTTON' || event.target.closest('button')) {
                return;
            }
            if (isActionPlaying) return;

            targetRotation = {
                groupX: 0,
                groupY: 0,
                groupZ: 0,
                headX: 0,
                headY: 0,
                headZ: 0
            };
            let clientX, clientY;
            if (event.type.startsWith('touch')) {
                // è§¦å±ï¼šä» touches[0] æ‹¿åæ ‡
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                // é¼ æ ‡ï¼šç›´æ¥æ‹¿
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // æ›´æ–°é¼ æ ‡åæ ‡ï¼ˆå½’ä¸€åŒ–ï¼‰
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersectsBody = raycaster.intersectObject(body, true);
            const intersectsHead = raycaster.intersectObject(headGroup, true);

            if (intersectsBody.length > 0 || intersectsHead.length > 0) {
                pressTimer = setTimeout(() => {
                    triggerTickle();
                }, 200);
            } else {
                isPressing = true;
                window.addEventListener('mousemove', updateHeadDirection);
                window.addEventListener('touchmove', updateHeadDirection); // è¿˜è¦åŠ è¿™ä¸€è¡Œ
            }
        }

        function onPressEnd(event) {
            isPressing = false;
            window.removeEventListener('mousemove', updateHeadDirection);
            window.removeEventListener('touchmove', updateHeadDirection);
            if (pressTimer) {
                clearTimeout(pressTimer); // ğŸ‘‰ æ¾æ‰‹äº†å°±å–æ¶ˆæŒ ç—’å®šæ—¶å™¨
                pressTimer = null;
            }
        }


        function updateHeadDirection(event) {
            if (!isPressing) return;

            let clientX, clientY;
            if (event.type.startsWith('touch')) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const x = (clientX / window.innerWidth) * 2 - 1;
            const y = -(clientY / window.innerHeight) * 2 + 1;
            targetRotation.headY = x * 0.3;
            targetRotation.headX = -y * 0.2;
        }
    </script>

</body>

</html>