<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>头跟鼠标动 + 表情动作 + Press朝向</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            position: relative;
            background-color: black;
            display: flex;
            flex-direction: column;
            height:100vh;
            width: 100vw;
            align-items: center;
        }

        menu{
            z-index: 10;
        }
        canvas {
            display: block;
            position: absolute;
            z-index: 1;
        }

        .buttons {
            position: absolute;
            /* top: 20px;
            left: 20px; */
            bottom:5em;
            z-index: 10;
        }

        .buttons button {
            margin-right: 10px;
            padding: 10px 15px;
            font-size: 16px;
        }
    </style>
</head>

<body>

    <menu>
        <img alt="logo" src="assets/logo.png" width="100">
    </menu>
    <canvas id="xiaoyuan"></canvas>
    <div class="buttons">
        <button onclick="triggerAction('greet')">打招呼</button>
        <button onclick="triggerAction('happy')">开心</button>
        <button onclick="triggerAction('sad')">悲伤</button>
        <button onclick="triggerAction('think')">思考</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        const canvas = document.getElementById("xiaoyuan");

        let scene, camera, renderer;
        let body, headGroup, head;
        let targetRotation = {
            x: 0,
            y: 0
        };
        let isActionPlaying = false; // 控制是否可以press朝向
        let isPressing = false; // 是否按着


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isTickling = false;
        let tickleStartTime = 0;
        let laughSound;

        let faceSprite;
        const textureLoader = new THREE.TextureLoader();

        // 创建Sprite
        function createFaceSprite() {
            const faceTexture = textureLoader.load('assets/Asset 2.png'); // 初始表情
            const faceMaterial = new THREE.SpriteMaterial({
                map: faceTexture,
                transparent: true
            });

            faceSprite = new THREE.Sprite(faceMaterial);

            // 表情相对于头的位置（可以根据模型大小微调）
            faceSprite.position.set(0, 0.15, 0.5);
            faceSprite.scale.set(0.18, 0.1, 1);

            head.add(faceSprite); // 表情挂在head上
        }



        init();
        animate();

        // 初始化xiaoyuan
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color("black");

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1, 3);

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 2, 3);
            scene.add(light);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            const loader = new THREE.GLTFLoader();

            loader.load('assets/hunban-body.glb', function (gltf) {
                body = gltf.scene;
                body.position.set(0, 0.5, 0);
                scene.add(body);
            });

            loader.load('assets/hunban-head.glb', function (gltf) {
                headGroup = new THREE.Group();
                head = gltf.scene;
                head.position.set(0, 0, 0);
                headGroup.add(head);

                headGroup.position.set(0, 1.1, 0);
                scene.add(headGroup);

                console.log("head position in group:", head.position);
                createFaceSprite();
            });

            //   window.addEventListener('mousemove', onMouseMove);
            //   window.addEventListener('touchmove', onTouchMove);
            window.addEventListener('resize', onWindowResize);
            //   window.addEventListener('mousedown', onPress);
            window.addEventListener('mousedown', onPressStart);
            window.addEventListener('mouseup', onPressEnd);

        }

        // 适应窗口大小变化
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // xiaoyuan的动画循环
        function animate() {
            requestAnimationFrame(animate);

            if (headGroup) {
                headGroup.rotation.y += (targetRotation.y - headGroup.rotation.y) * 0.1;
            }

            if (head) {
                if (isTickling) {
                    // 挠痒痒期间头左右快速震动
                    head.rotation.z = Math.sin((Date.now() - tickleStartTime) * 0.05) * 0.2;
                } else {
                    // 正常归零
                    head.rotation.x += (targetRotation.x - head.rotation.x) * 0.1;
                }

                renderer.render(scene, camera);
            }
        } 
        
        // 按钮触发动作
        function triggerAction(type) {
            if (isActionPlaying) return; // 如果正在播放，不允许再次点击

            isActionPlaying = true;

            let startTime = Date.now();

            // 设置不同动作
            function updateAction() {
                const elapsed = (Date.now() - startTime) / 800; // 0~1之间

                if (type === 'greet') {
                    // 头左右摇两下
                    targetRotation.y = Math.sin(elapsed * Math.PI * 4) * 0.3;
                } else if (type === 'happy') {
                    // 头快速上下点两下
                    targetRotation.x = Math.sin(elapsed * Math.PI * 4) * 0.2;
                } else if (type === 'sad') {
                    // 头缓慢低下
                    targetRotation.x = 0.3 * Math.min(elapsed, 1);
                } else if (type === 'think') {
                    // 头微微歪斜
                    targetRotation.y = 0.2 * Math.min(elapsed, 1);
                    targetRotation.x = -0.1 * Math.min(elapsed, 1);
                }

                if (elapsed < 1) {
                    requestAnimationFrame(updateAction);
                } else {
                    // 动作结束
                    isActionPlaying = false;
                }
            }

            updateAction();
        }

        // 挠痒痒
        function triggerTickle() {
            if (isTickling) return; // 如果正在挠，不要重复挠

            isTickling = true;
            tickleStartTime = Date.now();

            if (laughSound) {
                laughSound.currentTime = 0;
                laughSound.play();
            }

            // 0.8秒后停止挠
            setTimeout(() => {
                isTickling = false;
                // 归零
                if (head) {
                    head.rotation.set(0, 0, 0);
                    head.position.set(0, 0, 0);
                }
            }, 800);
        }

        // 目光跟随
        function onPressStart(event) {
            if (isActionPlaying) return;
            // 更新鼠标坐标（归一化）
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersectsBody = raycaster.intersectObject(body, true); // true表示包括子对象
            const intersectsHead = raycaster.intersectObject(head, true);
            if (intersectsBody.length > 0 || intersectsHead.length > 0) {
                // 点到了IP形象（头）
                triggerTickle();
            } else {
                // 没点到，正常进入拖动
                isPressing = true;
                updateHeadDirection(event);
                window.addEventListener('mousemove', updateHeadDirection);
            }
        }

        function onPressEnd(event) {
            isPressing = false;
            window.removeEventListener('mousemove', updateHeadDirection);
        }

        function updateHeadDirection(event) {
            if (!isPressing) return;
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = -(event.clientY / window.innerHeight) * 2 + 1;
            targetRotation.y = x * 0.3;
            targetRotation.x = -y * 0.2;
        }
    </script>

</body>

</html>